# 动态规划专题  
5.py 字符串的最长回文字串问题  
要点：  
1， dp[i到j] = dp[i+1到j-1] if s[i] == s[j] else 0  
2， 回文串两种扩散方式，单个位置扩散和两个位置扩散 
      
53.py 数组最大连续子序列的和  
要点：  
定义一个数组，dp[]，dp[i]以第i个元素为结尾的一段最大子序和。求dp[i]时，假设前面dp[0]到dp[i-1]都已经求出来了，dp[i-1]表示的是以i-1为结尾的最大子序和，若dp[i-1]小于0，则dp[i]加上前面的任意长度的序列和都会小于不加前面的序列（即自己本身一个元素是以自己为结尾的最大自序和）。  

62.py和63.py 均为二维数组从左上走到右下不同路径数量求解问题，区别是62.py没有路障，63.py具有路障限制  
dp[i,j] 表示从起点（0，0）到达（i,j）的走法，每一次只能选择往右走和往下走  
62.py 状态转移矩阵为 dp[i][j] = dp[i-1][j] + dp[i][j-1] if i != 0 and j !=0  else 1  
63.py 在62.py状态转移矩阵的基础上需要添加是否有障碍物的判断，具体来说：对于0行（0列），发现障碍物则该位置以及以后的位置的状态转移矩阵值均为0；对于其他（i，j）点来说，发现障碍物，则dp[i,j] = 0  
